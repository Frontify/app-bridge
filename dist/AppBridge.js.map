{"version":3,"sources":["webpack://AppBridge/webpack/universalModuleDefinition","webpack://AppBridge/webpack/bootstrap","webpack://AppBridge/webpack/runtime/define property getters","webpack://AppBridge/webpack/runtime/hasOwnProperty shorthand","webpack://AppBridge/webpack/runtime/make namespace object","webpack://AppBridge/./src/errors/TimeoutReachedError.ts","webpack://AppBridge/./src/errors/FetchError.ts","webpack://AppBridge/./src/Actions.ts","webpack://AppBridge/./src/Messenger.ts","webpack://AppBridge/./src/AppBridge.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","TimeoutReachedError","Error","FetchError","FetchKey","DispatchKey","Messenger","tokenLength","Math","random","toString","substr","this","message","window","top","postMessage","token","timeout","Promise","resolve","reject","addEventListener","event","response","data","success","once","setTimeout","AppBridge","messenger","dispatch","DispatchCloseApp","fetch","GetAppState","getMessageToken","GetThirdPartyOauth2Token","subscribeResponse","OAUTH2_TIMEOUT","state","PutAppState","asset","PostExternalAsset"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,YAAa,GAAIH,GACE,iBAAZC,QACdA,QAAmB,UAAID,IAEvBD,EAAgB,UAAIC,IARtB,CASGK,MAAM,WACT,M,mBCTA,IAAIC,EAAsB,CCA1B,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3E,EAAwB,CAACM,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClF,EAAyBd,IACH,oBAAXkB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeV,EAASkB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeV,EAAS,aAAc,CAAEoB,OAAO,M,qnDCHlCC,E,uZACjB,WAAYd,GAAa,O,4FAAA,0DACeA,EADf,iC,YADoBe,Q,ijDCA5BC,E,uZACjB,WAAYhB,GAAa,O,4FAAA,6CACEA,EADF,a,YADWe,Q,0KCF5BE,EAOAC,ECeSC,E,WAArB,c,4FAAA,SACqB,KAAAC,YAAsB,E,oDAEhC,WACH,OAAOC,KAAKC,SAASC,SAAS,IAAIC,OAAO,EAAGC,KAAKL,e,yBAG9C,SAAeM,GACGC,OAAOC,IACfC,YAAYH,EAAS,O,+BAG/B,SAAqB1B,EAAe8B,GAA6B,IAAdC,EAAc,uDAAJ,IAChE,OAAO,IAAIC,SAAQ,SAACC,EAASC,GACzBP,OAAOQ,iBACH,WACA,SAACC,GACG,IAAMC,EAA4CD,EAAME,KAEpDD,EAASP,QAAUA,GAASO,EAASrC,MAAQA,IAIjDqC,EAASE,QACHN,EAAQ,CACJM,QAASF,EAASE,QAClBD,KAAMD,EAASC,OAEnBJ,EAAO,IAAIlB,EAAWhB,OAEhC,CAAEwC,MAAM,IAGZC,YAAW,WACPP,EAAO,IAAIpB,EAAoBd,MAChC+B,W,yfDzDf,SAAYd,GACR,4BACA,sDACA,4BACA,wCAJJ,CAAYA,MAAQ,KAOpB,SAAYC,GACR,8BADJ,CAAYA,MAAW,K,IEAFwB,E,WAIjB,c,4FAAA,SACIjB,KAAKkB,UAAY,IAAIxB,E,uDAGlB,WACHM,KAAKmB,SAAS1B,EAAY2B,oB,uDAGvB,sHACIpB,KAAKqB,MAAY7B,EAAS8B,cAD9B,gD,iHAIA,0GACGjB,EAAQL,KAAKkB,UAAUK,kBAC7BvB,KAAKkB,UAAUd,YAAY,CAAE7B,IAAKiB,EAASgC,yBAA0BnB,UAFlE,kBAIIL,KAAKkB,UAAUO,kBAClBjC,EAASgC,yBACTnB,EACAY,EAAUS,iBAPX,gD,oGAWA,WAAqBC,GAArB,yGACI3B,KAAKqB,MAAY7B,EAASoC,YAAaD,IAD3C,gD,2GAIA,WAAwBE,GAAxB,yGACI7B,KAAKqB,MAAsC7B,EAASsC,kBAAmBD,IAD3E,gD,oEAIC,SAAStD,GACb,IAAM8B,EAAQL,KAAKkB,UAAUK,kBAC7BvB,KAAKkB,UAAUd,YAAY,CAAE7B,MAAK8B,Y,iDAG9B,WACJ9B,EACAsC,GAFI,6FAIER,EAAQL,KAAKkB,UAAUK,kBAC7BvB,KAAKkB,UAAUd,YAAyB,CAAE7B,MAAK8B,QAAOQ,SALlD,kBAOGb,KAAKkB,UAAUO,kBAAgClD,EAAK8B,IAPvD,gD,gFAtCO,EAAAqB,eAAiB,I","file":"AppBridge.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"AppBridge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AppBridge\"] = factory();\n\telse\n\t\troot[\"AppBridge\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { FetchKey } from \"../Actions\";\n\nexport default class TimeoutReachedError extends Error {\n    constructor(key: FetchKey) {\n        super(`Timeout for call with key \"${key}\" expired. Call was aborted.`);\n    }\n}\n","import { FetchKey } from \"../Actions\";\n\nexport default class FetchError extends Error {\n    constructor(key: FetchKey) {\n        super(`Call with key ${key} failed.`);\n    }\n}\n","export enum FetchKey {\n    GetAppState = \"getAppState\",\n    GetThirdPartyOauth2Token = \"getThirdPartyOAuth2Token\",\n    PutAppState = \"putAppState\",\n    PostExternalAsset = \"postExternalAsset\",\n}\n\nexport enum DispatchKey {\n    DispatchCloseApp = \"closeApp\",\n}\n","import { DispatchKey, FetchKey } from \"./Actions\";\nimport TimeoutReachedError from \"./errors/TimeoutReachedError\";\nimport FetchError from \"./errors/FetchError\";\n\nexport interface CrossDocumentMessage<T> {\n    key: DispatchKey | FetchKey;\n    token: string;\n    data?: T;\n}\n\nexport interface CrossDocumentMessageResponse<T> {\n    success: boolean;\n    key: DispatchKey | FetchKey;\n    token: string;\n    data: T;\n}\n\nexport interface AppBridgeResponse<T> {\n    success: boolean;\n    data: T;\n}\n\nexport default class Messenger {\n    private readonly tokenLength: number = 6;\n\n    public getMessageToken(): string {\n        return Math.random().toString(20).substr(2, this.tokenLength);\n    }\n\n    public postMessage<T>(message: CrossDocumentMessage<T>): void {\n        const parentWindow = window.top;\n        parentWindow.postMessage(message, \"*\");\n    }\n\n    public subscribeResponse<T>(key: FetchKey, token: string, timeout = 3000): Promise<AppBridgeResponse<T>> {\n        return new Promise((resolve, reject) => {\n            window.addEventListener(\n                \"message\",\n                (event) => {\n                    const response: CrossDocumentMessageResponse<T> = event.data;\n\n                    if (response.token !== token || response.key !== key) {\n                        return;\n                    }\n\n                    response.success\n                        ? resolve({\n                              success: response.success,\n                              data: response.data,\n                          })\n                        : reject(new FetchError(key));\n                },\n                { once: true },\n            );\n\n            setTimeout(() => {\n                reject(new TimeoutReachedError(key));\n            }, timeout);\n        });\n    }\n}\n","import Messenger, { AppBridgeResponse } from \"./Messenger\";\nimport { DispatchKey, FetchKey } from \"./Actions\";\nimport { Asset, ThirdPartyOAuth2Token } from \"./ResponseType\";\nimport { PostExternalAssetParams } from \"./RequestType\";\n\nexport { DispatchKey, FetchKey } from \"./Actions\";\n\nexport default class AppBridge {\n    private messenger: Messenger;\n    private static OAUTH2_TIMEOUT = 5 * 60 * 1000;\n\n    constructor() {\n        this.messenger = new Messenger();\n    }\n\n    public closeApp(): void {\n        this.dispatch(DispatchKey.DispatchCloseApp);\n    }\n\n    public async getAppState<T>(): Promise<AppBridgeResponse<T>> {\n        return this.fetch<T, T>(FetchKey.GetAppState);\n    }\n\n    public async getThirdPartyOAuth2Token(): Promise<AppBridgeResponse<ThirdPartyOAuth2Token>> {\n        const token = this.messenger.getMessageToken();\n        this.messenger.postMessage({ key: FetchKey.GetThirdPartyOauth2Token, token });\n\n        return this.messenger.subscribeResponse<ThirdPartyOAuth2Token>(\n            FetchKey.GetThirdPartyOauth2Token,\n            token,\n            AppBridge.OAUTH2_TIMEOUT,\n        );\n    }\n\n    public async putAppState<T>(state: T): Promise<AppBridgeResponse<T>> {\n        return this.fetch<T, T>(FetchKey.PutAppState, state);\n    }\n\n    public async postExternalAsset(asset: PostExternalAssetParams): Promise<AppBridgeResponse<Asset>> {\n        return this.fetch<PostExternalAssetParams, Asset>(FetchKey.PostExternalAsset, asset);\n    }\n\n    private dispatch(key: DispatchKey): void {\n        const token = this.messenger.getMessageToken();\n        this.messenger.postMessage({ key, token });\n    }\n\n    private async fetch<RequestType, ResponseType>(\n        key: FetchKey,\n        data?: RequestType,\n    ): Promise<AppBridgeResponse<ResponseType>> {\n        const token = this.messenger.getMessageToken();\n        this.messenger.postMessage<RequestType>({ key, token, data });\n\n        return this.messenger.subscribeResponse<ResponseType>(key, token);\n    }\n}\n"],"sourceRoot":""}