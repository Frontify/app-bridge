{"version":3,"sources":["webpack://AppBridge/webpack/universalModuleDefinition","webpack://AppBridge/webpack/bootstrap","webpack://AppBridge/webpack/runtime/define property getters","webpack://AppBridge/webpack/runtime/hasOwnProperty shorthand","webpack://AppBridge/webpack/runtime/make namespace object","webpack://AppBridge/webpack/startup","webpack://AppBridge/./src/errors/TimeoutReachedError.ts","webpack://AppBridge/./src/errors/FetchError.ts","webpack://AppBridge/./src/Actions.ts","webpack://AppBridge/./src/Messenger.ts","webpack://AppBridge/./src/AppBridge.ts"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","__webpack_exports__","TimeoutReachedError","Error","FetchError","FetchKey","DispatchKey","Messenger","tokenLength","Math","random","toString","substr","this","message","window","top","postMessage","token","timeout","Promise","resolve","reject","addEventListener","subscribeResponseCallback","event","response","data","success","removeEventListener","setTimeout","version","AppBridge","messenger","dispatch","DispatchCloseApp","fetch","GetAppState","getMessageToken","GetThirdPartyOauth2Token","subscribeResponse","OAUTH2_TIMEOUT","state","PutAppState","ClearAppState","asset","PostExternalAsset","__webpack_modules__"],"mappings":"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","file":"AppBridge.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"AppBridge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AppBridge\"] = factory();\n\telse\n\t\troot[\"AppBridge\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module doesn't tell about it's top-level declarations so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[557](0, __webpack_exports__, __webpack_require__);\n","import { FetchKey } from \"../Actions\";\n\nexport default class TimeoutReachedError extends Error {\n    constructor(key: FetchKey) {\n        super(`Timeout for call with key \"${key}\" expired. Call was aborted.`);\n    }\n}\n","import { FetchKey } from \"../Actions\";\n\nexport default class FetchError extends Error {\n    constructor(key: FetchKey) {\n        super(`Call with key ${key} failed.`);\n    }\n}\n","export enum FetchKey {\n    GetAppState = \"getAppState\",\n    GetThirdPartyOauth2Token = \"getThirdPartyOAuth2Token\",\n    PutAppState = \"putAppState\",\n    ClearAppState = \"clearAppState\",\n    PostExternalAsset = \"postExternalAsset\",\n}\n\nexport enum DispatchKey {\n    DispatchCloseApp = \"closeApp\",\n}\n","import { DispatchKey, FetchKey } from \"./Actions\";\nimport TimeoutReachedError from \"./errors/TimeoutReachedError\";\nimport FetchError from \"./errors/FetchError\";\n\nexport interface CrossDocumentMessage<T> {\n    key: DispatchKey | FetchKey;\n    token: string;\n    data?: T;\n}\n\nexport interface CrossDocumentMessageResponse<T> {\n    success: boolean;\n    key: DispatchKey | FetchKey;\n    token: string;\n    data: T;\n}\n\nexport interface AppBridgeResponse<T> {\n    success: boolean;\n    data: T;\n}\n\nexport default class Messenger {\n    private readonly tokenLength: number = 6;\n\n    public getMessageToken(): string {\n        return Math.random().toString(20).substr(2, this.tokenLength);\n    }\n\n    public postMessage<T>(message: CrossDocumentMessage<T>): void {\n        const parentWindow = window.top;\n        parentWindow.postMessage(message, \"*\");\n    }\n\n    public subscribeResponse<T>(key: FetchKey, token: string, timeout = 3000): Promise<AppBridgeResponse<T>> {\n        return new Promise((resolve, reject) => {\n            const subscribeResponseCallback = (event: MessageEvent) => {\n                debugger;\n                const response: CrossDocumentMessageResponse<T> = event.data;\n\n                if (response.token !== token || response.key !== key) {\n                    return;\n                }\n\n                response.success\n                    ? resolve({\n                          success: response.success,\n                          data: response.data,\n                      })\n                    : reject(new FetchError(key));\n\n                window.removeEventListener(\"message\", subscribeResponseCallback);\n            };\n\n            window.addEventListener(\"message\", subscribeResponseCallback);\n\n            setTimeout(() => {\n                reject(new TimeoutReachedError(key));\n            }, timeout);\n        });\n    }\n}\n","import Messenger, { AppBridgeResponse } from \"./Messenger\";\nimport { DispatchKey, FetchKey } from \"./Actions\";\nimport { Asset, ThirdPartyOAuth2Token } from \"./ResponseType\";\nimport { PostExternalAssetParams } from \"./RequestType\";\n\nexport { DispatchKey, FetchKey } from \"./Actions\";\n\nimport PackageJson from \"../package.json\";\nexport const version = PackageJson.version;\n\nexport default class AppBridge {\n    private messenger: Messenger;\n    private static OAUTH2_TIMEOUT = 5 * 60 * 1000;\n\n    constructor() {\n        this.messenger = new Messenger();\n    }\n\n    public closeApp(): void {\n        this.dispatch(DispatchKey.DispatchCloseApp);\n    }\n\n    public async getAppState<T>(): Promise<AppBridgeResponse<T>> {\n        return this.fetch<T, T>(FetchKey.GetAppState);\n    }\n\n    public async getThirdPartyOAuth2Token(): Promise<AppBridgeResponse<ThirdPartyOAuth2Token>> {\n        const token = this.messenger.getMessageToken();\n        this.messenger.postMessage({ key: FetchKey.GetThirdPartyOauth2Token, token });\n\n        return this.messenger.subscribeResponse<ThirdPartyOAuth2Token>(\n            FetchKey.GetThirdPartyOauth2Token,\n            token,\n            AppBridge.OAUTH2_TIMEOUT,\n        );\n    }\n\n    public async putAppState<T>(state: T): Promise<AppBridgeResponse<T>> {\n        return this.fetch<T, T>(FetchKey.PutAppState, state);\n    }\n\n    public async clearAppState(): Promise<AppBridgeResponse<null>> {\n        return this.fetch<null, null>(FetchKey.ClearAppState);\n    }\n\n    public async postExternalAsset(asset: PostExternalAssetParams): Promise<AppBridgeResponse<Asset>> {\n        return this.fetch<PostExternalAssetParams, Asset>(FetchKey.PostExternalAsset, asset);\n    }\n\n    private dispatch(key: DispatchKey): void {\n        const token = this.messenger.getMessageToken();\n        this.messenger.postMessage({ key, token });\n    }\n\n    private async fetch<RequestType, ResponseType>(\n        key: FetchKey,\n        data?: RequestType,\n    ): Promise<AppBridgeResponse<ResponseType>> {\n        const token = this.messenger.getMessageToken();\n        this.messenger.postMessage<RequestType>({ key, token, data });\n\n        return this.messenger.subscribeResponse<ResponseType>(key, token);\n    }\n}\n"],"sourceRoot":""}